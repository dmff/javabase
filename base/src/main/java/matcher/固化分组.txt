五、固化分组(atomic groups)

使用固化分组的匹配与正常的匹配并无差别，但是如果匹配进行到此结构之后（也就是，进行到闭括号之后），
那么此结构体中的所有备用状态都会被放弃。也就是说，在固化分组匹配结束时，它已经匹配的文本已经固化
为一个单元，只能作为整体而保留或放弃。括号内的子表达式中未尝试过的备用状态都不复存在了，所以回溯
永远也不能回到固化分组的位置。固化分组能够提高匹配效率，而且能自己控制什么能匹配和什么不能匹配。

以"(.dd(?>[1-9]?))d+"为例在固化分组内，量词能够正常工作，所以如果「[1-9]」不能匹配，正则表达式
会返回「? 」留下的备用状态。然后匹配脱离固化分组，继续前进到「d+」。在这种情况下，当控制权离开固化
分组时，没有备用状态需要放弃（因为在固化分组中没有创建任何备用状态）。
如果「[1-9]」能够匹配，匹配脱离固化分组之后，「? 」保存的备用状态仍然存在。但是，因为它属于已经结束
的固化分组，所以会被抛弃。匹配‘.625’或者‘.625000’时就会发生这种情况。在后一种情况下，放弃那些状态
不会带来任何麻烦，因为「d+」匹配的是‘.625000’，到这里正则表达式已经完成匹配。但是对于‘.625’来说，
因为「d+」无法匹配，正则引擎需要回溯，但回溯又无法进行，因为备用状态已经不存在了。既然没有能够回溯的
备用状态，整体匹配也就失败，‘.625’不需要处理，而这正是我们期望的。