方法invokeAny和invokeAll的解析：
	1.都具有阻塞性
	2.invokeAny取得第一个完成任务的经过值，当第一个任务执行完成后，会调用interrupt方法将其他任务中断，
	  结果if(thread.isInterrupted)代码来决定是否继续运行
	3.invokeAll等待全部线程任务执行完毕后，取得全部完成任务的结果值
	
  invokeAny:
  	1.无if(thread中断)代码，已经获得第一个运行的结果，其他的线程继续运行；有if代码，使用throw中断异常
  	   来中断线程，虽然抛出了异常，main线程不能捕获，如果想捕获，需要在callable使用try-catch显示捕获
  	
  	2.invokeAny与执行慢的任务异常，执行慢的任务出现异常时，默认情况是不会再控制台输出，可以使用try-catch显示捕获  
  	    注意：子线程出现异常不影响main线程的主流程，抛出的异常在main方法没有被捕获
  	
  	3.invokeAny与执行快的任务异常，控制台不会输出异常信息，需要try-catch显示捕获，而等待后面执行慢的任务返回结果
  	   从此可以推出，如果知道最后都没有获得返回值，则抛出异常，并且最终的异常是最后出现的异常 
  	   注意：如果使用try-catch捕获了异常，并且没有抛出的话，main线程不能获取B的返回值，因为线程池会认为A任务
  	   		是正确的，不回去是关注点切换到下一个任务
  	   		
  	4.invokeAny与全部异常，程序抛出executioexeception，是执行快任务的特别版本，返回最后一个出现的异常
  	
  	5.invokeAny超时，在指定时间内没有获取返回值的话，抛出异常
  		可以结合if(线程中断)和throw是线程中断执行，只有使用debug模式下才会看到超时异常,显示使用try-catch可以看到
  		
  invokeAll:
  	1.返回所有任务的执行结果，执行的效果是阻塞的，要把所有的结果都取回时才会继续往下运行
  	
  	2.invokeAll快的正常慢的异常:invokeAll对异常是可处理的，直接进入try-catch语句块处理，
  		如果使用invokeAll某一个任务正确的返回值时，则其他callable跑出去的异常在main方法是不被处理的
  		如果使用invokeAll都没有正确的返回值，则最后callable抛出去的异常在mian方法中被处理
  	
  	3.invokeAll快的异常慢的正常:后面的慢的正常的返回值不会返回，因为第一次循环时出现异常，直接进入catch语句块，
  		后面的代码不会执行，全部出现异常时，打印最先出现的异常
  		
  	4.测试超时：指定全部任务在指定的时间没有完成，则抛出异常
  		分三种情况：
 		  1.先慢后快：慢的抛出CancellationException异常，而不是timeout异常，后面的for循环不会执行
          2.先快后慢：快的会有返回值，慢的会抛出CancellationException异常
          3.全慢：和先慢后快情形一样，通过for循环获取结果，第一次获取的时候出现异常，后面的不会执行